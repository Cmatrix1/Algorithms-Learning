# Algorithms-Learning
این یک ریپازیتوری هست که من میخوام جزوات و نکته های اموزش algorithms رو که خودم نیاز دارم رو بنویسم 


# شروع 
خب به احتمال زیاد همش رو هم داخل این فایل ریدمی بنویسم

اول از همه برای اموزش الگوریتم ها از سایت مونگارد استفاده میکنم و ویدیو هارو با سرعت 1.5X شروع به دیدن میکنم

---
### اولین موضوع پیچیدگی زمانی یا Time Complexity 

 اولین موضوعی هم که بنظر باید یادبگیرم پیچیدگی زمانی هستش
که فک میکنم سایت مونگارد کافی نیست واسه یادگیری این مبحث قصد دارم یه چنتا ویدیو توی یوتیوب هم ببینم
حالا فعلا چنتا ویدیو اول مونگارد رو میبینم بعد میرم سراغ یوتیوب

1. کامپلکسیتی Constant Time
```cod
Constant Time : O(log)
```


 چیزی که تا الان فهمیدم مفهمومش اینه که اگه دیتای ورودی زیاد شد سرعت الگوریتم کم نشه
حالا برم مثالش رو هم ببینم 

خب الان کامل متوجه این مبحث شدم میگه که اگه یک الگوریتمی داشتیم که هرچقدر دیتاش زیاد شد سرعتش تغییری نکنه مثل برگردوندن ابجکت اول یک لیست 
یه کار جالبی هم که کردم این بود که از ChatGPT هم راجب این الگوریتم پرسیدم و اونم جواب خوبی بهم داد


*جواب هوش مصنوعی عزیز:*

زمان اجرای الگوریتم ها به صورت معمول با توجه به ورودی های آن‌ها تغییر می کند. اما برخی از الگوریتم ها، مستقل از حجم داده ورودی، همیشه در زمان ثابت اجرا می‌شوند. این روشن است که خیلی از الگوریتم های پرکاربرد در علوم کامپیوتر مانند دسته‌بندی، جستجو و ... می‌توانند در زمان ثابت اجرا شوند. به این نوع از الگوریتم ها، الگوریتم های O(1) یا الگوریتم های constant time می‌گویند.


2. کامپلکسیتی Logarithm Time
```code
Logarithm Time O(log n)
```
الگوریتمی هست که با هر بار excute کردنش بازه زمانی اش نصف میشه 

*بطور دقیقترش رو هوش مصنوعی میگه:*

کامپلکسیتی زمانی لگاریتمی (Logarithmic Time Complexity) یا همان O(log n)، به این معناست که زمان اجرای الگوریتم با توجه به لگاریتم حجم داده ورودی افزایش می‌یابد. به عبارت دیگر، در الگوریتم های با پیچیدگی زمانی log n، با افزایش اندازه ورودی، زمان اجرای الگوریتم به صورت لگاریتمی افزایش می‌یابد.

این کدی هست که من خودم بدون کمک گرفتن از هیچ جا نوشتم فقط با توجه به توضیحاتی که راجب این الگوریتم شنیدم 
```python
number = 68
lst = [i for i in range(242)]
lst.sort()

def binary_search(nums, my_num):
    while not find:
        index = round(len(nums) / 2)
        midnum = nums[index]
        if my_num < midnum:
            nums = nums[:index]
        elif my_num > midnum:
            nums = nums[index:]
        elif my_num == midnum:
            find = True
            return index

binary_search(lst, number)
```

و بعد هم نظر هوش مصنوعی رو راجب این کد پرسیدم و اونم این رو گفت:

کد بالا الگوریتم جستجوی دودویی را پیاده‌سازی کرده است. کامپلکسیتی این الگوریتم O(log n) است، زیرا در هر مرحله حداقل نصف اعضای لیست بررسی می‌شوند و در نتیجه با افزایش تعداد اعضای لیست، زمان اجرای الگوریتم به صورت لگاریتمی افزایش می‌یابد. در این الگوریتم تنها یک حلقه while وجود دارد که به طور متوسط حداکثر log2(n) دور اجرا می‌شود. بنابراین، کامپلکسیتی زمانی این الگوریتم O(log n) است.



پس یعنی کارم رو درست انجام دادم هرچند الگوریتم ساده ای هست :)))


 
یه نکته ای رو همینجا اضافه کنم اونم اینکه این اولین باری هست که دارم در حین آموزش دیدن اینجور جزوه ای مینویسم جزوه که چه عرض کنم مقاله شده :)
و حقیقتن خیلی لذت بخشه برام چون هم چیزایی که یادگرفتم رو مکتوب کردم هم در اینده به دردم میخوره و هم شاید به درد بقیه بخوره 

خب بریم سراغ الگوریتم بعدی

2. کامپلکسیتی Linear Time 
```code 
 Linear Time O(n)
 ```
 
 خب این الگوریتم برای زمانی هست که شما هرچی دیتای بیشتری داشته باشی زمان بیشتری هم نیاز داری برای انجام عملیات 
 
 
*توضیح هوش مصنوعی :*
خب، یک مثال از الگوریتم خطی در زمان اجرای O(n) برای مثال می‌تواند محاسبه مجموع تمام عناصر یک لیست باشد. فرض کنید لیست را به عنوان ورودی دریافت کرده‌اید:
```python
def linear_sum(numbers):
    total = 0
    for num in numbers:
        total += num
    return total
```

در این کد، با استفاده از یک حلقه for، به طول n لیست ورودی را یکبار پیمایش می‌کنیم و هر بار مقدار هر عنصر را به مجموع اضافه می‌کنیم. این کد در زمان خطیO(n)اجرامی‌شود


